/* esp_dht_final.ino
   - VERSÃO CORRIGIDA PARA CORS (ACEITA OPTIONS/PREFLIGHT)
   - ARQUITETURA DE ALERTA/HISTÓRICO SEPARADA
   - Chama /atualizar_estado.php (Alertas) em intervalo fixo
   - Chama /salvar_dht.php (Histórico) com base em thresholds
*/

#include <ESP8266WiFi.h>
#include <WiFiManager.h>
#include <ESP8266HTTPClient.h>
#include <ESP8266WebServer.h>
#include <ESP8266mDNS.h>
#include <DHT.h>
#include <EEPROM.h>

// ---------- CONFIG ----------
// URL para SALVAR HISTÓRICO (configurado via WiFiManager)
char serverURL[128] = "http://192.168.1.100/Arduino/api/salvar_dht.php";
// URL para ATUALIZAR ESTADO (derivado automaticamente)
char stateURL[128] = "http://192.168.1.100/Arduino/api/atualizar_estado.php";

#define DHTPIN 4
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// Intervalo principal de LEITURA (a cada 2s)
const unsigned long READ_INTERVAL = 2000UL;
// Intervalo de ATUALIZAÇÃO DE ESTADO (Alertas) (a cada 30s)
const unsigned long STATE_UPDATE_INTERVAL = 30000UL;
const int DHT_MAX_RETRIES = 3;

// EEPROM (COM ESPAÇO PARA O URL)
#define EEPROM_SIZE 192
const int ADDR_MAGIC = 0;
const int ADDR_TEMP  = 4;
const int ADDR_HUM   = 8;
const int ADDR_URL   = 12; // serverURL (salvar_dht.php)
const uint8_t EEPROM_MAGIC = 0xA5;

float tempThreshold = 2.0f;
float humThreshold  = 10.0f;

ESP8266WebServer server(80);

// ---------- ESTADO ----------
unsigned long lastRead = 0; // Timer para LEITURA
unsigned long lastStateUpdate = 0; // Timer para ATUALIZAR ESTADO (Alertas)
int failCount = 0;

float latestTemp = NAN, latestHum = NAN;
float lastSentTemp = NAN, lastSentHum = NAN; // Para o Threshold 1 (Histórico)


// =============================================================
// --- SEÇÃO DE FUNÇÕES ---
// =============================================================

void printNetworkInfo() {
  Serial.println("=== Rede ===");
  Serial.print("SSID: "); Serial.println(WiFi.SSID());
  Serial.print("IP: "); Serial.println(WiFi.localIP());
  Serial.print("Gateway: "); Serial.println(WiFi.gatewayIP());
  Serial.print("Mascara: "); Serial.println(WiFi.subnetMask());
  Serial.println("============");
}

// --- FUNÇÃO DE SALVAR ---
void saveConfigToEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.write(ADDR_MAGIC, EEPROM_MAGIC);
  
  // Salva thresholds
  union { float f; uint8_t b[4]; } u;
  u.f = tempThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_TEMP + i, u.b[i]);
  u.f = humThreshold;
  for (int i = 0; i < 4; ++i) EEPROM.write(ADDR_HUM + i, u.b[i]);

  // Salva serverURL (char[128])
  for (int i = 0; i < 128; ++i) {
    EEPROM.write(ADDR_URL + i, 0);
  }
  for (int i = 0; i < 128; ++i) {
    EEPROM.write(ADDR_URL + i, serverURL[i]);
    if (serverURL[i] == '\0') break; 
  }
  
  EEPROM.commit();
  EEPROM.end();
  Serial.println("Configuracao salva na EEPROM (Thresholds + URL).");
  Serial.printf("URL salva: %s\n", serverURL);
}

// --- FUNÇÃO DE CARREGAR ---
void loadConfigFromEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
  uint8_t magic = EEPROM.read(ADDR_MAGIC);
  if (magic == EEPROM_MAGIC) {
    // Carrega thresholds
    union { float f; uint8_t b[4]; } u;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_TEMP + i);
    tempThreshold = u.f;
    for (int i = 0; i < 4; ++i) u.b[i] = EEPROM.read(ADDR_HUM + i);
    humThreshold = u.f;

    // Carrega serverURL
    char loadedURL[128];
    for (int i = 0; i < 128; ++i) {
      loadedURL[i] = (char)EEPROM.read(ADDR_URL + i);
      if (loadedURL[i] == '\0') break;
    }
    loadedURL[127] = '\0'; 

    if (strlen(loadedURL) > 10 && strncmp(loadedURL, "http", 4) == 0) {
      strcpy(serverURL, loadedURL);
    }
    
    Serial.println("Configuracao carregada da EEPROM.");
    Serial.printf("URL: %s, Temp: %.2f, Hum: %.2f\n", serverURL, tempThreshold, humThreshold);
    
  } else {
    Serial.println("EEPROM vazia — usando defaults e salvando.");
    saveConfigToEEPROM(); 
  }
  EEPROM.end();
}


bool readDHT(float &temp, float &hum) {
  for (int attempt = 1; attempt <= DHT_MAX_RETRIES; ++attempt) {
    temp = dht.readTemperature();
    hum  = dht.readHumidity();
    if (!isnan(temp) && !isnan(hum)) return true;

    Serial.printf("Leitura DHT falhou (attempt %d/%d). temp=%s hum=%s\n",
                  attempt, DHT_MAX_RETRIES,
                  isnan(temp) ? "NaN" : String(temp,2).c_str(),
                  isnan(hum)  ? "NaN" : String(hum,2).c_str()
                 );
    delay(2000); // DHT needs ~2s between reads
  }
  return false;
}

// Função para ENVIAR PARA HISTÓRICO (salvar_dht.php)
bool sendToServer(float temp, float hum) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Não enviado (histórico): sem conexão WiFi");
    return false;
  }
  WiFiClient client;
  HTTPClient http;
  
  if (!http.begin(client, serverURL)) { 
     Serial.println("HTTP.begin (histórico) falhou");
     return false; 
  }

  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  char postBody[64];
  snprintf(postBody, sizeof(postBody), "temp=%.2f&hum=%.2f", temp, hum);
  
  Serial.print("POST (Histórico) >> "); Serial.println(postBody);
  Serial.print("Para >> "); Serial.println(serverURL); 

  int httpCode = http.POST(postBody);
  if (httpCode > 0) {
    Serial.print("HTTP code: "); Serial.println(httpCode);
  } else {
    Serial.print("Erro POST (Histórico): "); Serial.println(http.errorToString(httpCode));
  }
  http.end();
  return (httpCode >= 200 && httpCode < 300);
}

// NOVA FUNÇÃO para ATUALIZAR ESTADO (atualizar_estado.php)
bool sendStateUpdate(float temp, float hum) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Não enviado (estado): sem conexão WiFi");
    return false;
  }
  WiFiClient client;
  HTTPClient http;
  
  if (!http.begin(client, stateURL)) { // Usa stateURL
    Serial.println("HTTP.begin (estado) falhou");
    return false;
  }

  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  char postBody[64];
  snprintf(postBody, sizeof(postBody), "temp=%.2f&hum=%.2f", temp, hum);
  
  Serial.print("POST (Estado/Alerta) >> "); Serial.println(postBody);
  Serial.print("Para >> "); Serial.println(stateURL); 

  int httpCode = http.POST(postBody);
  if (httpCode > 0) {
    Serial.print("HTTP code: "); Serial.println(httpCode);
  } else {
    Serial.print("Erro POST (Estado): "); Serial.println(http.errorToString(httpCode));
  }
  
  http.end();
  return (httpCode >= 200 && httpCode < 300);
}

// =============================================================
// --- SETUP ---
// =============================================================

void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println();
  Serial.println("=== ESP8266 DHT11 - Iniciando (CORS FIXED) ===");
  dht.begin();

  // ETAPA 1: Carrega a config (inclusive o serverURL)
  loadConfigFromEEPROM();

  // --- Conexão WiFi com WiFiManager ---
  WiFiManager wifiManager; 
  WiFiManagerParameter custom_server_url("server_url", "URL Salvar Histórico (salvar_dht.php)", serverURL, 128);
  wifiManager.addParameter(&custom_server_url);

  if (!wifiManager.autoConnect("AutoConnectAP", "password")) {
    Serial.println("Falha ao conectar e o tempo de config expirou");
    delay(3000); ESP.restart(); delay(5000);
  }
  
  Serial.println("WiFi conectado com sucesso!");
  printNetworkInfo(); 

  // --- (Config mDNS) ---
  Serial.println("Iniciando mDNS (http://esp-dht.local)");
  if (!MDNS.begin("esp-dht")) { 
    Serial.println("Erro ao iniciar mDNS!");
  } else {
    MDNS.addService("http", "tcp", 80);
    Serial.println("mDNS iniciado. Acesse em: http://esp-dht.local");
  }

  // ETAPA 2: ATUALIZA serverURL e Salva na EEPROM
  strcpy(serverURL, custom_server_url.getValue());
  saveConfigToEEPROM(); // Salva o serverURL e thresholds

  // ETAPA 3: DERIVA o stateURL
  strcpy(stateURL, serverURL);
  char* p = strstr(stateURL, "salvar_dht.php"); // Encontra "salvar_dht.php"
  if (p) {
    strcpy(p, "atualizar_estado.php");
  }

  Serial.println("--- Configurações Ativas ---");
  Serial.print("URL Histórico: "); Serial.println(serverURL);
  Serial.print("URL Estado/Alerta: "); Serial.println(stateURL);
  Serial.println("---------------------------------");

  // --- ENDPOINTS DO SERVIDOR WEB (CORRIGIDOS) ---
  
  // CORREÇÃO: Removemos "HTTP_GET" para capturar todos os métodos (GET e OPTIONS)
  server.on("/status", []() {
    // SE for uma verificação de segurança (OPTIONS / Preflight)
    if (server.method() == HTTP_OPTIONS) {
      server.sendHeader("Access-Control-Allow-Origin", "*");
      server.sendHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
      server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
      server.send(204); // Responde OK sem conteúdo
      return;
    }

    // SE for o pedido normal (GET)
    char buffer[192]; 
    snprintf(buffer, sizeof(buffer),
      "{\"status\":\"ok\",\"temperatura\":%.2f,\"umidade\":%.2f,\"saved_temp\":%.2f,\"saved_hum\":%.2f}",
      isnan(latestTemp) ? 0.0 : latestTemp,
      isnan(latestHum)  ? 0.0 : latestHum,
      isnan(lastSentTemp) ? 0.0 : lastSentTemp,
      isnan(lastSentHum)  ? 0.0 : lastSentHum
    );
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", buffer); 
  });
  
  // CORREÇÃO: Mesma lógica para o /config
  server.on("/config", []() {
    if (server.method() == HTTP_OPTIONS) {
      server.sendHeader("Access-Control-Allow-Origin", "*");
      server.sendHeader("Access-Control-Allow-Methods", "GET, OPTIONS");
      server.sendHeader("Access-Control-Allow-Headers", "*");
      server.send(204);
      return;
    }

    bool updated = false;
    if (server.hasArg("temp")) {
      tempThreshold = server.arg("temp").toFloat();
      updated = true;
    }
    if (server.hasArg("hum")) {
      humThreshold = server.arg("hum").toFloat();
      updated = true;
    }
    if (updated) {
      saveConfigToEEPROM();
    }
    String js = "{\"status\":\"ok\",\"tempThreshold\":" + String(tempThreshold,2) + ",\"humThreshold\":" + String(humThreshold,2) + "}";
  
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "application/json", js);
  });

  server.on("/ping", []() {
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.send(200, "text/plain", "pong");
  });

  // --- RESET VIA SOFTWARE ---
  server.on("/resetwifi", HTTP_GET, []() {
    Serial.println("Recebida solicitação /resetwifi...");
    server.send(200, "text/html", 
      "<h1>Configuracoes de WiFi limpas!</h1>"
      "<p>O ESP vai reiniciar em 3 segundos...</p>");
    delay(3000); 
    WiFiManager wifiManager; 
    wifiManager.resetSettings();
    EEPROM.begin(EEPROM_SIZE);
    EEPROM.write(ADDR_MAGIC, 0x00); 
    EEPROM.commit();
    EEPROM.end();
    ESP.restart();
  });

  server.begin();
  Serial.println("HTTP server iniciado.");
}

// =============================================================
// --- LOOP ---
// =============================================================

void loop() {
  unsigned long now = millis();
  server.handleClient();
  MDNS.update();

  // --- LÓGICA DE LEITURA (BLOCO 1) ---
  if (now - lastRead >= READ_INTERVAL) {
    lastRead = now;

    float temp = NAN, hum = NAN;
    if (!readDHT(temp, hum)) {
      Serial.println("Falha: não foi possível ler DHT após retries.");
      failCount++;
      return;
    }
    latestTemp = temp;
    latestHum  = hum;
    Serial.printf("Leitura -> Temp: %.2f °C  Hum: %.2f %%\n", temp, hum);
  }

  if (isnan(latestTemp)) {
    delay(10);
    return;
  }

  // --- LÓGICA DE ALERTA (BLOCO 2) ---
  if (now - lastStateUpdate >= STATE_UPDATE_INTERVAL) {
    lastStateUpdate = now;
    sendStateUpdate(latestTemp, latestHum);
  }

  // --- LÓGICA DE HISTÓRICO (BLOCO 3) ---
  bool shouldSend = false;
  if (isnan(lastSentTemp) || isnan(lastSentHum)) {
    shouldSend = true;
    Serial.println("Primeiro envio para histórico.");
  } else {
    float dt = fabs(latestTemp - lastSentTemp);
    float dh = fabs(latestHum  - lastSentHum);
    
    if (dt >= tempThreshold || dh >= humThreshold) {
      shouldSend = true;
      Serial.printf("Diferença (Histórico) > threshold (dT=%.2f, dH=%.2f): gravando...\n", dt, dh);
    }
  }

  if (shouldSend) {
    bool ok = sendToServer(latestTemp, latestHum); 
    if (ok) {
      lastSentTemp = latestTemp;
      lastSentHum  = latestHum;
      Serial.println("Envio (Histórico) OK.");
      failCount = 0;
    } else {
      Serial.println("Envio (Histórico) falhou.");
      failCount++;
    }
  }

  delay(10);
}
